Summary of https://github.com/interledger/rfcs/issues/359


Interledger nodes: senders, connectors and receivers
Interledger edges: accounts they have with one another
ledger : just another type of connector

different types of accounts:
  - credit relationship or trustline
  - payment channel: crypto-equivalent of a check:
    One party signs something called a claim that the other party can take to someone else
    (such as a blockchain) to get paid.
    It reduces trust needed between the parties because the settlement is enforceable.

In ILP, we use unsecured payment channels: What we do is we transfer a claim after receiving a fulfillment.
If conditions are only evaluated by connectors and ledger plugins only do unconditional transfers,
then conditions are an Interledger concern, not a ledger layer concern.

Ledger Plugin Interface:

BEFORE:                            | AFTER:
=======                            | ======
interface Transfer {               | class Plugin {
  amount: string,                  |   async sendData(data: Buffer): Buffer
  executionCondition: Buffer,      |   async sendMoney(amount: string): void
  expiresAt: string,               | }
  ilp: Buffer                      | const ilpFulfillmentPacket =
}                                  |     await plugin.sendData(ilpPaymentPacket)
                                   | await plugin.sendMoney('10')
interface FulfillmentInfo {        |
  fulfillment: Buffer,             |("""what ilp-plugin-xrp-paychan already does""")
  ilp: Buffer                      |
}                                  | Certain logic that needed to be
                                   | reimplemented in every plugin before,
class Plugin {                     | such as verifying the fulfillment etc.
  sendTransfer(transfer: Transfer):| is now part of the connector / sender.
      FulfillmentInfo              |
}                                  | """ the ledger plugin interface
                                   | is now arguably timeless:
const {                            | it can send integers of information
   fulfillment,                    | (bytes) and it can send integers of value"""
   data: ilpFulfillmentPacket      |
} = await plugin.sendTransfer({    |
  amount: '10',                    |
  executionCondition:              |
    Buffer.from('4D..', 'base64'), |
  expiresAt:                       |
    '2016-05-18T12:00:00.000Z',    |
  ilp: ilpPaymentPacket            |
})                                 |

sendData triggers  next [sendData, sendMoney] at each hop.

Sender --sendData-> Connector 1 --sendData-> Connector 2 --sendData-> Receiver
   |                        |                        |
   `----sendMoney->         `----sendMoney->         `----sendMoney->

                             <--- InterledgerRejectionError

[executionCondition, expiry] is moved to ILP payment packet.
                             ILP packet changes at each hop
[fulfillment]                is moved inside the ILP fulfillment packet.



Escrow will go away under the enlightenment.
Escrow is just transferring money from one account to another.
It is still possible to implement the escrow pattern using this new LPI.
Since ledgers are just connectors now:
    Alice -> Escrow: sends money
    Alice -> Escrow: prepare packet
    Escrow-> Bob   : prepare packet
    Bob   -> Ellie : fulfillment packet
    Escrow-> Bob   : money
    Escrow-> Alice : fulfillment packet

As with routing, escrow functionality can also be implemented in the ledger plugin
if there is a ledger that is fast and permissive enough and can do escrow,
but doesn't understand ILP. Since no such ledgers exist (at least none that are
fast enough for actually doing ILP on them) this is a theoretical exercise.

Any future ledgers that may be built specifically for ILP that wish to implement
the escrow pattern should think of themselves as connectors.

(left out of ticket description: how balances are handled under this new view)

This change is very close to the one proposed in ILP3. I proposed merging the fields from
the ILP packet into the transfer, this merges the transfer fields into the ILP packet.


Member sappenin commented 12 days ago
    The substantive differences between these approaches [ILP3 and this issue] are that having a standard packet encoding:
        Saves the overhead of re-encoding the packet at each hop
        Makes it easier to ensure that connectors pass on extensions they don't understand

Looking at the HTLA types:
    Trustlines: A trustline (with settlement) is case 1/2, usually with a very rare settlement.
    Simple Payment Channels: Also case 1/2, except we can settle more cheaply and therefore frequently.
    On-Ledger Holds/Escrow (using HTLCs): Case 3 (escrow). Can be implemented with a virtual connector or by natively supporting ILP in the escrow system.
    Conditional Payment Channels (with HTLCs): Case 3, but now the escrowing connector is not in the flow, so it has to be implemented as a virtual connector in the plugin. Not an option I would recommend, but it can be done.

-------------------
Yeah; Currently having the BTP channel also available to send claims is useful,
which is why the plugin bundles the money connection together with the data connection.
If we do find in the future that it's useful to have them as two separate plugins,
it would be trivial to implement in our current architecture:

connect () {              sendMoney (amount) {    sendData (data) {
   moneyPlugin.connect()    return moneyPlugin      return dataPlugin
   dataPlugin.connect()       .send(amount)           .send(data)
}                         }                       }


Does ilp3 invalidate the existing ilp architecture? #21

